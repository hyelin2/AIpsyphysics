<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lucky Box (RN→RP + Server Save)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="lib/jspsych.css">
  <script src="lib/jspsych.js"></script>
  <script src="lib/plugin-html-keyboard-response.js"></script>

  <style>
    :root { color-scheme: dark; }
    body { background:#111; color:#eee; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 24px; }
    .title { font-size: 24px; color:#9fe4ff; margin: 0 0 8px; }
    .score { font-weight:600; color:#7fffd4; margin-bottom: 16px; }
    .boxes { display:flex; justify-content:space-around; align-items:center; height:56vh; gap:6vw; }
    .box { width:220px; height:220px; border:4px solid #888; border-radius:16px;
           display:flex; align-items:center; justify-content:center; font-size:52px; }
    .label { text-align:center; margin-top:8px; font-size:18px; color:#ccc; }
    .keys { text-align:center; margin-top:14px; color:#aaa; }
    .feedback { font-size:36px; text-align:center; margin-top:12vh; }
    .small { font-size:13px; color:#aaa; }
    .center { text-align:center; }
    .btn { display:inline-block; padding:10px 14px; border:1px solid #666; border-radius:10px; }
    #hud-trials {
      position: fixed; right: 14px; bottom: 14px;
      font-size: 12px; color: #9b9b9b; background: rgba(255,255,255,0.03);
      padding: 6px 10px; border: 1px solid #3a3a3a; border-radius: 8px; z-index: 20;
      user-select: none; pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">Lucky Box (RN→RP)</div>
    <div id="score" class="score">Score: 0</div>
    <div id="jspsych"></div>
  </div>
  <div id="hud-trials">남은 시도: 600 / 600</div>

  <script>
    // =============== 저장 서버 설정 ===============
    const SAVE_ENDPOINT_BASE = 'https://script.google.com/macros/s/AKfycbwfMpOM130lgHBL_RbEtIL3ADe8upsce4fodeTl-DYMPaxN1suF8vL1UqVCyHJLu9Lg/exec';
    const SAVE_ENDPOINT = SAVE_ENDPOINT_BASE + '?task=luckybox';
    function getPID() {
      const fromQS = new URLSearchParams(location.search).get('pid');
      if (fromQS) return fromQS;
      const cached = localStorage.getItem('luckybox_pid');
      if (cached) return cached;
      const gen = 'L' + Math.random().toString(36).slice(2,10);
      localStorage.setItem('luckybox_pid', gen);
      return gen;
    }
    const PARTICIPANT_ID = getPID();

    // =============== 요소/상태 ===============
    const $score = document.getElementById('score');
    const $hud = document.getElementById('hud-trials');
    const logBuffer = []; // {ts,msg}
    function log(m) { const ts = new Date().toISOString(); logBuffer.push({ts, msg:m}); }

    // =============== 파라미터 ===============
    //
    const TOTAL_TRIALS = 3; //600
    const BLOCK_SIZE   = 1;//150

    const FEEDBACK_MS  = 700;
    const ITI_MS       = 400;

    // 키는 소문자 비교
    const LEFT_KEY  = 'arrowleft';
    const RIGHT_KEY = 'arrowright';

    const INIT_PROB_LEFT  = 0.7;
    const INIT_PROB_RIGHT = 0.3;

    function getBlockIndex(t) { return Math.floor(t / BLOCK_SIZE); }
    function isPenaltyBlock(blockIdx) { return blockIdx >= 2; }
    function getProbsForTrial(t) {
      const b = getBlockIndex(t);
      const reversed = (b === 1 || b === 3);
      return reversed
        ? { pL: INIT_PROB_RIGHT, pR: INIT_PROB_LEFT }
        : { pL: INIT_PROB_LEFT,  pR: INIT_PROB_RIGHT };
    }
    function updateHUD(remaining) { $hud.textContent = `남은 시도: ${remaining} / ${TOTAL_TRIALS}`; }

    let score = 0;
    function boxHTML() {
      return `
        <div class="boxes">
          <div>
            <div class="box">L</div>
            <div class="label">왼쪽 상자</div>
          </div>
          <div>
            <div class="box">R</div>
            <div class="label">오른쪽 상자</div>
          </div>
        </div>
        <div class="keys">키보드 <b>←</b> = 왼쪽 / <b>→</b> = 오른쪽</div>
      `;
    }

    // =============== 업로드 단 한 번만 실행하도록 가드 ===============
    let UPLOAD_DONE = false;

    // =============== jsPsych ===============
    const jsPsych = initJsPsych({
      display_element: 'jspsych',
      // ⛔ 여기서는 업로드 하지 않음(중복 방지)
      on_finish: () => {}
    });
    jsPsych.data.addProperties({
      task: 'luckybox',
      total_trials: TOTAL_TRIALS,
      block_size: BLOCK_SIZE,
      key_left: LEFT_KEY,
      key_right: RIGHT_KEY,
      init_prob_left: INIT_PROB_LEFT,
      init_prob_right: INIT_PROB_RIGHT,
      participant_id: PARTICIPANT_ID,
      start_time: new Date().toISOString()
    });

    const timeline = [];

    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="center" style="margin-top:14vh;">
          <div style="font-size:28px; margin-bottom:10px;">게임 설명</div>
          <div>키보드 화살표를 이용해서 두 개의 상자 중 하나를 고르세요.</div>
          <div class="small" style="margin-top:8px;">최대한 높은 Score를 기록하세요. 총 ${TOTAL_TRIALS}회 진행됩니다.</div>
          <div style="margin-top:18px;">
            <span class="btn">아무 키나 눌러 시작</span>
          </div>
        </div>
      `,
      on_finish: () => { updateHUD(TOTAL_TRIALS); }
    });

    for (let t = 0; t < TOTAL_TRIALS; t++) {
      const blockIdx = getBlockIndex(t);
      const penaltyOnMiss = isPenaltyBlock(blockIdx);
      const { pL, pR } = getProbsForTrial(t);

      // CHOICE
      timeline.push({
        type: jsPsychHtmlKeyboardResponse,
        stimulus: boxHTML,
        choices: [LEFT_KEY, RIGHT_KEY], // 소문자 키
        data: {
          phase: 'choice',
          trial_index_zero: t,
          block_index: blockIdx,
          penalty_on_miss: penaltyOnMiss ? 1 : 0,
          prob_left: pL,
          prob_right: pR
        },
        on_start: () => {
          const remaining = TOTAL_TRIALS - t;
          updateHUD(remaining);
          if (t % BLOCK_SIZE === 0) {
            const reversed = (blockIdx === 1 || blockIdx === 3) ? 1 : 0;
            log(`BLOCK START: block=${blockIdx} reversed=${reversed} penalty=${penaltyOnMiss?1:0} probs(L=${pL},R=${pR})`);
            jsPsych.data.write({
              phase: 'block_start',
              trial_index_zero: t,
              block_index: blockIdx,
              reversed: reversed,
              penalty_on_miss: penaltyOnMiss ? 1 : 0,
              prob_left: pL, prob_right: pR,
              timestamp: new Date().toISOString()
            });
          }
        },
        on_finish: (data) => {
          const keyRaw = data.response ?? '';
          const key = String(keyRaw).toLowerCase();

          const p = (key === LEFT_KEY) ? pL : pR;
          const rewarded = Math.random() < p;

          if (rewarded) score += 1;
          else if (penaltyOnMiss) score -= 1;

          data.choice_key = keyRaw; // 'ArrowLeft' 등 원본
          data.choice_label = (key === LEFT_KEY) ? 'left' : 'right';
          data.rewarded   = rewarded ? 1 : 0;
          data.score_after = score;
          data.timestamp   = new Date().toISOString();

          document.getElementById('score').textContent = `Score: ${score}`;

          log(
            `trial=${t} block=${blockIdx} key=${keyRaw} rt=${Math.round(data.rt)}ms ` +
            `rewarded=${rewarded?1:0} penalty=${penaltyOnMiss?1:0} score=${score} ` +
            `prob(L=${pL.toFixed(2)},R=${pR.toFixed(2)})`
          );
        }
      });

      // FEEDBACK
      timeline.push({
        type: jsPsychHtmlKeyboardResponse,
        choices: "NO_KEYS",
        trial_duration: FEEDBACK_MS,
        data: { phase: 'feedback', trial_index_zero: t, block_index: blockIdx },
        stimulus: () => {
          const last = jsPsych.data.get().last(1).values()[0];
          const hit = !!last.rewarded;
          const feedbackText = hit
            ? "✅ 보상 +1"
            : (isPenaltyBlock(getBlockIndex(last.trial_index_zero)) ? "❌ 꽝 -1" : "⭕ 꽝 (감점 없음)");
          return `<div class="feedback">${feedbackText}</div>`;
        }
      });

      // ITI
      timeline.push({
        type: jsPsychHtmlKeyboardResponse,
        choices: "NO_KEYS",
        trial_duration: ITI_MS,
        stimulus: () => `<div class="center small" style="margin-top:16vh;">잠시만요…</div>`,
        data: { phase: 'iti', trial_index_zero: t, block_index: blockIdx }
      });
    }

    // END
    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      stimulus: () => `
        <div class="center" style="margin-top:14vh;">
          <div style="font-size:28px; margin-bottom:10px;">끝!</div>
          <div>최종 점수: <b>${score}</b></div>
          <div class="small" style="margin-top:8px;">스페이스바를 누르면 결과 저장이 시작됩니다.</div>
        </div>
      `,
      on_finish: async () => {
        updateHUD(0);
        await saveDataToServer();   // ← 업로드는 여기서 단 한 번
        // 로컬 백업
        try { jsPsych.data.get().localSave('csv','luckybox_results.csv'); log("trial data saved"); } catch (e) { log("trial save failed: "+e.message); }
        try {
          const header = "timestamp,message\n";
          const rows = logBuffer.map(x => `${x.ts},"${x.msg.replace(/"/g,'""')}"`).join("\n");
          const csv = header + rows + "\n";
          const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'luckybox_logs.csv';
          document.body.appendChild(a); a.click(); a.remove();
        } catch (e) {}
      }
    });

    jsPsych.run(timeline);

    // =============== 서버 전송(단 한 번만) ===============
    async function saveDataToServer() {
      if (UPLOAD_DONE) return true;  // ★ 중복 방지

      const rows = jsPsych.data.get().filter({phase:'choice'}).values().map(d => ({
        trial_index_zero: d.trial_index_zero ?? null,
        id: String(d.trial_index_zero ?? ''),
        headline_text: '',
        stimulus_type: 'luckybox',
        topic: `block=${d.block_index}`,
        target_valence: `pL=${(d.prob_left??0).toFixed(2)}|pR=${(d.prob_right??0).toFixed(2)}`,
        cue_type: '',
        choice_label: d.choice_label ?? '',
        choice_key: d.choice_key ?? '',
        rt: d.rt ?? null,
        correct: d.rewarded ?? null
      }));

      const payload = {
        task: 'luckybox',
        participant_id: PARTICIPANT_ID,
        meta: { mode: 'RN_to_RP', ua: navigator.userAgent },
        rows
      };

      try {
        await fetch(SAVE_ENDPOINT, {
          method: 'POST',
          headers: {'Content-Type':'text/plain'}, // 프리플라이트 회피
          body: JSON.stringify(payload),
          mode: 'no-cors',
          keepalive: true
        });
        UPLOAD_DONE = true; // ★ 시도 후에는 재전송 막기
        return true;
      } catch (e) {
        localStorage.setItem('luckybox_pending_upload', JSON.stringify(payload));
        return false;
      }
    }

    // 대기열 재전송 & 이탈 보험 (업로드 전일 때만)
    (async () => {
      const q = localStorage.getItem('luckybox_pending_upload');
      if (q && !UPLOAD_DONE) {
        try {
          await fetch(SAVE_ENDPOINT, { method:'POST', headers:{'Content-Type':'text/plain'}, body:q, mode:'no-cors' });
          localStorage.removeItem('luckybox_pending_upload');
          UPLOAD_DONE = true;
        } catch(_) {}
      }
    })();
    window.addEventListener('visibilitychange', () => {
      if (!UPLOAD_DONE && document.visibilityState === 'hidden') {
        saveDataToServer();
      }
    });
  </script>
</body>
</html>
